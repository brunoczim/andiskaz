<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A cross-platform library for opening OS pipes."><meta name="keywords" content="rust, rustlang, rust-lang, os_pipe"><title>os_pipe - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../os_pipe/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate os_pipe</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.9.2</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all os_pipe's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="os_pipe" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">os_pipe</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/os_pipe/lib.rs.html#1-440" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A cross-platform library for opening OS pipes.</p>
<p>The standard library uses pipes to read output from child processes,
but it doesn’t expose a way to create them directly. This crate
fills that gap with the <code>pipe</code> function. It also includes some
helpers for passing pipes to the <code>std::process::Command</code> API.</p>
<ul>
<li><a href="https://docs.rs/os_pipe">Docs</a></li>
<li><a href="https://crates.io/crates/os_pipe">Crate</a></li>
<li><a href="https://github.com/oconnor663/os_pipe.rs">Repo</a></li>
</ul>
<p>Usage note: The main purpose of <code>os_pipe</code> is to support the
higher-level <a href="https://github.com/oconnor663/duct.rs"><code>duct</code></a>
library, which handles most of the same use cases with much less
code and no risk of deadlocks. <code>duct</code> can run the entire example
below in one line of code.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<p>Join the stdout and stderr of a child process into a single stream,
and read it. To do that we open a pipe, duplicate its write end, and
pass those writers as the child’s stdout and stderr. Then we can
read combined output from the read end of the pipe. We have to be
careful to close the write ends first though, or reading will block
waiting for EOF.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">os_pipe::pipe</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::process</span>::{<span class="ident">Command</span>, <span class="ident">Stdio</span>};

<span class="comment">// This command prints &quot;foo&quot; to stdout and &quot;bar&quot; to stderr. It</span>
<span class="comment">// works on both Unix and Windows, though there are whitespace</span>
<span class="comment">// differences that we&#39;ll account for at the bottom.</span>
<span class="kw">let</span> <span class="ident">shell_command</span> <span class="op">=</span> <span class="string">&quot;echo foo &amp;&amp; echo bar &gt;&amp;2&quot;</span>;

<span class="comment">// Ritual magic to run shell commands on different platforms.</span>
<span class="kw">let</span> (<span class="ident">shell</span>, <span class="ident">flag</span>) <span class="op">=</span> <span class="kw">if</span> <span class="macro">cfg!</span>(<span class="ident">windows</span>) { (<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/C&quot;</span>) } <span class="kw">else</span> { (<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>) };

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">child</span> <span class="op">=</span> <span class="ident">Command::new</span>(<span class="ident">shell</span>);
<span class="ident">child</span>.<span class="ident">arg</span>(<span class="ident">flag</span>);
<span class="ident">child</span>.<span class="ident">arg</span>(<span class="ident">shell_command</span>);

<span class="comment">// Here&#39;s the interesting part. Open a pipe, copy its write end, and</span>
<span class="comment">// give both copies to the child.</span>
<span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">reader</span>, <span class="ident">writer</span>) <span class="op">=</span> <span class="ident">pipe</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">writer_clone</span> <span class="op">=</span> <span class="ident">writer</span>.<span class="ident">try_clone</span>().<span class="ident">unwrap</span>();
<span class="ident">child</span>.<span class="ident">stdout</span>(<span class="ident">writer</span>);
<span class="ident">child</span>.<span class="ident">stderr</span>(<span class="ident">writer_clone</span>);

<span class="comment">// Now start the child running.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handle</span> <span class="op">=</span> <span class="ident">child</span>.<span class="ident">spawn</span>().<span class="ident">unwrap</span>();

<span class="comment">// Very important when using pipes: This parent process is still</span>
<span class="comment">// holding its copies of the write ends, and we have to close them</span>
<span class="comment">// before we read, otherwise the read end will never report EOF. The</span>
<span class="comment">// Command object owns the writers now, and dropping it closes them.</span>
<span class="ident">drop</span>(<span class="ident">child</span>);

<span class="comment">// Finally we can read all the output and clean up the child.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">String::new</span>();
<span class="ident">reader</span>.<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">output</span>).<span class="ident">unwrap</span>();
<span class="ident">handle</span>.<span class="ident">wait</span>().<span class="ident">unwrap</span>();
<span class="macro">assert!</span>(<span class="ident">output</span>.<span class="ident">split_whitespace</span>().<span class="ident">eq</span>(<span class="macro">vec!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]));</code></pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PipeReader.html" title="os_pipe::PipeReader struct">PipeReader</a></div><div class="item-right docblock-short"><p>The reading end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PipeWriter.html" title="os_pipe::PipeWriter struct">PipeWriter</a></div><div class="item-right docblock-short"><p>The writing end of a pipe, returned by <a href="fn.pipe.html"><code>pipe</code></a>.</p>
</div></div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stderr.html" title="os_pipe::dup_stderr fn">dup_stderr</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard error, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stdin.html" title="os_pipe::dup_stdin fn">dup_stdin</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard input, as a
<a href="struct.PipeReader.html"><code>PipeReader</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.dup_stdout.html" title="os_pipe::dup_stdout fn">dup_stdout</a></div><div class="item-right docblock-short"><p>Get a duplicated copy of the current process’s standard output, as a
<a href="struct.PipeWriter.html"><code>PipeWriter</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.pipe.html" title="os_pipe::pipe fn">pipe</a></div><div class="item-right docblock-short"><p>Open a new pipe and return a <a href="struct.PipeReader.html"><code>PipeReader</code></a> and <a href="struct.PipeWriter.html"><code>PipeWriter</code></a> pair.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="os_pipe" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>