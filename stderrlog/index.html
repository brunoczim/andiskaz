<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A simple logger to provide symantics similar to what is expected of most UNIX utilities by logging to stderr and the higher the verbosity the higher the log level. It supports the ability to provide timestamps at different granularities. As well as colorizing the different log levels."><title>stderrlog - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="stderrlog" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../stderrlog/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../stderrlog/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate stderrlog</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">stderrlog</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/stderrlog/lib.rs.html#9-569">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A simple logger to provide symantics similar to what is expected
of most UNIX utilities by logging to stderr and the higher the
verbosity the higher the log level. It supports the
ability to provide timestamps at different granularities. As
well as colorizing the different log levels.</p>
<h3 id="simple-use-case"><a href="#simple-use-case">Simple Use Case</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>log;
<span class="kw">extern crate </span>stderrlog;

<span class="kw">fn </span>main() {
    stderrlog::new().module(<span class="macro">module_path!</span>()).init().unwrap();

    <span class="macro">error!</span>(<span class="string">&quot;some failure&quot;</span>);

    <span class="comment">// ...
</span>}</code></pre></div>
<h2 id="structopt-example"><a href="#structopt-example">StructOpt Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>log;
<span class="kw">extern crate </span>stderrlog;
<span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>structopt;

<span class="kw">use </span>structopt::StructOpt;

<span class="doccomment">/// A StructOpt example
</span><span class="attr">#[derive(StructOpt, Debug)]
#[structopt()]
</span><span class="kw">struct </span>Opt {
    <span class="doccomment">/// Silence all output
    </span><span class="attr">#[structopt(short = <span class="string">&quot;q&quot;</span>, long = <span class="string">&quot;quiet&quot;</span>)]
    </span>quiet: bool,
    <span class="doccomment">/// Verbose mode (-v, -vv, -vvv, etc)
    </span><span class="attr">#[structopt(short = <span class="string">&quot;v&quot;</span>, long = <span class="string">&quot;verbose&quot;</span>, parse(from_occurrences))]
    </span>verbose: usize,
    <span class="doccomment">/// Timestamp (sec, ms, ns, none)
    </span><span class="attr">#[structopt(short = <span class="string">&quot;t&quot;</span>, long = <span class="string">&quot;timestamp&quot;</span>)]
    </span>ts: <span class="prelude-ty">Option</span>&lt;stderrlog::Timestamp&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>opt = Opt::from_args();

    stderrlog::new()
        .module(<span class="macro">module_path!</span>())
        .quiet(opt.quiet)
        .verbosity(opt.verbose)
        .timestamp(opt.ts.unwrap_or(stderrlog::Timestamp::Off))
        .init()
        .unwrap();
    <span class="macro">trace!</span>(<span class="string">&quot;trace message&quot;</span>);
    <span class="macro">debug!</span>(<span class="string">&quot;debug message&quot;</span>);
    <span class="macro">info!</span>(<span class="string">&quot;info message&quot;</span>);
    <span class="macro">warn!</span>(<span class="string">&quot;warn message&quot;</span>);
    <span class="macro">error!</span>(<span class="string">&quot;error message&quot;</span>);
}</code></pre></div>
<h3 id="docopt-example"><a href="#docopt-example">docopt Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>docopt;
<span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>log;
<span class="kw">extern crate </span>rustc_serialize;
<span class="kw">extern crate </span>stderrlog;

<span class="kw">use </span>docopt::Docopt;

<span class="kw">const </span>USAGE: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str = <span class="string">&quot;
Usage: program [-q] [-v...]
&quot;</span>;

<span class="attr">#[derive(Debug, RustcDecodable)]
</span><span class="kw">struct </span>Args {
    flag_q: bool,
    flag_v: usize,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>args: Args = Docopt::new(USAGE)
                            .and_then(|d| d.decode())
                            .unwrap_or_else(|e| e.exit());

    stderrlog::new()
            .module(<span class="macro">module_path!</span>())
            .quiet(args.flag_q)
            .timestamp(stderrlog::Timestamp::Second)
            .verbosity(args.flag_v)
            .init()
            .unwrap();
    <span class="macro">trace!</span>(<span class="string">&quot;trace message&quot;</span>);
    <span class="macro">debug!</span>(<span class="string">&quot;debug message&quot;</span>);
    <span class="macro">info!</span>(<span class="string">&quot;info message&quot;</span>);
    <span class="macro">warn!</span>(<span class="string">&quot;warn message&quot;</span>);
    <span class="macro">error!</span>(<span class="string">&quot;error message&quot;</span>);

    <span class="comment">// ...
</span>}</code></pre></div>
<h2 id="clap-example"><a href="#clap-example">clap Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>clap;
<span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>log;
<span class="kw">extern crate </span>stderrlog;

<span class="kw">use </span>clap::{Arg, App};
<span class="kw">use </span>std::str::FromStr;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>m = App::new(<span class="string">&quot;stderrlog example&quot;</span>)
        .version(<span class="macro">crate_version!</span>())
        .arg(Arg::with_name(<span class="string">&quot;verbosity&quot;</span>)
             .short(<span class="string">&quot;v&quot;</span>)
             .multiple(<span class="bool-val">true</span>)
             .help(<span class="string">&quot;Increase message verbosity&quot;</span>))
        .arg(Arg::with_name(<span class="string">&quot;quiet&quot;</span>)
             .short(<span class="string">&quot;q&quot;</span>)
             .help(<span class="string">&quot;Silence all output&quot;</span>))
        .arg(Arg::with_name(<span class="string">&quot;timestamp&quot;</span>)
             .short(<span class="string">&quot;t&quot;</span>)
             .help(<span class="string">&quot;prepend log lines with a timestamp&quot;</span>)
             .takes_value(<span class="bool-val">true</span>)
             .possible_values(<span class="kw-2">&amp;</span>[<span class="string">&quot;none&quot;</span>, <span class="string">&quot;sec&quot;</span>, <span class="string">&quot;ms&quot;</span>, <span class="string">&quot;ns&quot;</span>]))
        .get_matches();

    <span class="kw">let </span>verbose = m.occurrences_of(<span class="string">&quot;verbosity&quot;</span>) <span class="kw">as </span>usize;
    <span class="kw">let </span>quiet = m.is_present(<span class="string">&quot;quiet&quot;</span>);
    <span class="kw">let </span>ts = m.value_of(<span class="string">&quot;timestamp&quot;</span>).map(|v| {
        stderrlog::Timestamp::from_str(v).unwrap_or_else(|<span class="kw">_</span>| {
            clap::Error {
                message: <span class="string">&quot;invalid value for &#39;timestamp&#39;&quot;</span>.into(),
                kind: clap::ErrorKind::InvalidValue,
                info: <span class="prelude-val">None</span>,
            }.exit()
        })
    }).unwrap_or(stderrlog::Timestamp::Off);

    stderrlog::new()
        .module(<span class="macro">module_path!</span>())
        .quiet(quiet)
        .verbosity(verbose)
        .timestamp(ts)
        .init()
        .unwrap();
    <span class="macro">trace!</span>(<span class="string">&quot;trace message&quot;</span>);
    <span class="macro">debug!</span>(<span class="string">&quot;debug message&quot;</span>);
    <span class="macro">info!</span>(<span class="string">&quot;info message&quot;</span>);
    <span class="macro">warn!</span>(<span class="string">&quot;warn message&quot;</span>);
    <span class="macro">error!</span>(<span class="string">&quot;error message&quot;</span>);
}</code></pre></div>
<h4 id="log-compatibility"><a href="#log-compatibility"><code>log</code> Compatibility</a></h4>
<p>The 0.3.x versions of <code>stderrlog</code> aim to provide compatibility with
applications using <code>log</code> 0.3.x</p>
<h4 id="rust-compatibility"><a href="#rust-compatibility">Rust Compatibility</a></h4>
<p><code>stderrlog</code> is serious about backwards compat. <code>stderrlog</code>
pins the minimum required version of Rust in the CI build.
Bumping the minimum version of Rust is a minor breaking
change and requires a minor version to be bumped.</p>
<p>The minimum supported Rust version for this release is 1.16.0.</p>
<h4 id="module-level-logging"><a href="#module-level-logging">Module Level Logging</a></h4>
<p><code>stderrlog</code> has the ability to limit the components which can log.
Many crates use <a href="https://docs.rs/log/*/log/">log</a> but you may not
want their output in your application. For example
<a href="https://docs.rs/hyper/*/hyper/">hyper</a> makes heavy use of log but
when your application receives <code>-vvvvv</code> to enable the <code>trace!()</code>
messages you don’t want the output of <code>hyper</code>’s <code>trace!()</code> level.</p>
<p>To support this <code>stderrlog</code> includes a <code>module()</code> method allowing
you to specify the modules that are allowed to log. The examples
above use the <code>module_path!()</code> macro to enable logging only for
the binary itself but none of its dependencies. To enable logging
from extra crates just add another call to <code>module()</code> with the
name of the crate. To enable logging for only a module within
that crate specifiy <code>crate::module</code> to <code>module()</code>. crates and
modules will be named the same way would would include them in
source code with <code>use</code> (e.g. <code>some-crate</code> would be <code>some_crate</code>).</p>
<p>For a good example of how the module level logging works see the
<a href="https://github.com/cardoe/stderrlog-rs/tree/master/examples/large-example">large-example
crate</a>
under examples, you’ll want to run the
following binaries to see all the examples:</p>
<ul>
<li><code>cargo run --bin large-example --</code></li>
<li><code>cargo run --bin another --</code></li>
<li><code>cargo run --bin yet --</code></li>
</ul>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.StdErrLog.html" title="struct stderrlog::StdErrLog">StdErrLog</a></div><div class="desc docblock-short">Data specific to this logger</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ColorChoice.html" title="enum stderrlog::ColorChoice">ColorChoice</a></div><div class="desc docblock-short">ColorChoice represents the color preferences of an end user.</div></li><li><div class="item-name"><a class="enum" href="enum.Timestamp.html" title="enum stderrlog::Timestamp">Timestamp</a></div><div class="desc docblock-short">State of the timestampping in the logger.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.new.html" title="fn stderrlog::new">new</a></div><div class="desc docblock-short">creates a new stderr logger</div></li></ul></section></div></main></body></html>